#!/usr/bin/env python
#
# Copyright 2012 SUSE Linux
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import argparse
import glob
import os
import re

from metaextract import utils as meta_utils
from packaging.requirements import Requirement


def parse_update_spec_file(specfile, contents, run_requires):
    found_requires = set()
    all_requires = set()

    for d in run_requires:
        all_requires.add(d)

        if re.search(r'^(Build)?Requires(?:\(.*\))?:\s+%s' % (d), contents,
                     flags=re.MULTILINE | re.IGNORECASE) >= 0:
            found_requires.add(d)

        contents = re.sub(
            r'^(Requires(?:\(.*\))?:[ \t]+)(%s)(?:[ \t].*)?$' % (d),
            r'\g<1>\g<2>%s' %
            (" >= " + run_requires[d] if run_requires[d] else ""),
            contents, flags=re.MULTILINE | re.IGNORECASE)[:]

    if not specfile.endswith("-doc.spec"):
        spec_requires = set()
        for m in re.finditer(r"^Requires(?:\(.*\))?:[ \t]+python-([\w\d\.-]+)",
                             contents, flags=re.MULTILINE | re.IGNORECASE):
            spec_requires.add("python-%s" % m.group(1))

        if all_requires.difference(found_requires):
            for d in all_requires.difference(found_requires):
                print("ERROR: %s is missing in %s"  % (d, specfile))

        for d in spec_requires.difference(all_requires):
            if d.lower() in all_requires:
                continue
            print("W: %s is not found in upstream" % d)

    return contents


def update_spec_files(run_requires):
    for specfile in glob.glob('./*.spec'):
        try:
            f = open(specfile, 'r+')
            contents = f.read()
            f.seek(0)
            f.truncate()
            contents = parse_update_spec_file(specfile, contents, run_requires)
            f.write(contents)
        finally:
            f.close()


def sanitize_requirements(requirements):
    d = dict()

    for l in requirements:
        # strip away comments
        l = re.sub('#.*', ' ', l)
        # strip away whitespace
        l = re.sub('[ \t]*', '', l)
        # ignore for now the requirements like '-e git://'
        l = re.sub(r'\s*-e.*', '', l)

        # in egg/requires.txt, there are sections starting with "[" for markers
        if not l or l.startswith("-f") or l.startswith("["):
            continue

        m = re.match('^http://tarballs.openstack.org/([^/]+)/', l)
        if m:
            l = m.group(1)

        if re.match('^python-(.*)client', l):
            l = re.sub(r'^python-(.+client)', r'\g<1>', l)

        r = Requirement(l)
        if r.marker:
            # TODO (toabctl): currently we hardcode python 2.7 and linux2
            # see https://www.python.org/dev/peps/pep-0508/#environment-markers
            marker_env = {'python_version': '2.7', 'sys_platform': 'linux'}
            if not r.marker.evaluate(environment=marker_env):
                continue

        pkg_name = r.name
        version_dep = None

        if r.specifier:
            # we want the lowest possible version
            # NOTE(toabctl): "min(r.specifier)" doesn't work.
            lowest = None
            for s in r.specifier:
                # we don't want a lowest version which is not allowed
                if s.operator == '!=':
                    continue
                if not lowest or s.version < lowest.version:
                    lowest = s

            if lowest:
                version_dep = lowest.version

        d["python-%s" % (pkg_name)] = version_dep

    # ignore some requirements
    ignore_requires = (
        'python-discover',  # not needed since we only care about >= py27
        'python-coverage',
        'python-sphinx', 'python-setuptools_git',
        'python-setuptools',
        'python-setuptools-git', 'python-distribute',
        'python-pylint', 'python-hacking',
        'python-docutils', 'python-oslo.sphinx', 'python-oslosphinx',
        'python-hacking', 'python-qpid-python')

    real_requires = dict()
    for k in set(d).difference(ignore_requires):
        real_requires[k] = d[k]

    return real_requires


def get_tarball_candidate():
    # Try to find the tarball
    candidates = set()
    for d in os.listdir('.'):
        if '.tar.' in d:
            candidates.add(d)

    candidates = list(candidates)
    candidates.sort(key=lambda x: os.stat(
        os.path.join(os.getcwd(), x)).st_mtime, reverse=True)
    return candidates[0]


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Python Requires')
    parser.add_argument('--outdir',
                        help='osc service parameter that does nothing')
    args = parser.parse_args()

    filename = get_tarball_candidate()

    # dict of tuple with requirements and their source
    run_requires_list = list()
    requires_meta = meta_utils.from_archive(filename)
    if requires_meta['data']['install_requires']:
        run_requires_list += requires_meta['data']['install_requires']
    if requires_meta['data']['extras_require']:
        run_requires_list += requires_meta['data']['extras_require']
    if requires_meta['data']['tests_require']:
        run_requires_list += requires_meta['data']['tests_require']

    run_requires = sanitize_requirements(run_requires_list)

    update_spec_files(run_requires)
